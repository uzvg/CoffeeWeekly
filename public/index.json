
[{"content":"刚开始学习Linux Shell的时候，有两个变量总是让人傻傻分不清楚，它们就是$@跟$*，还有\u0026quot;$@\u0026quot;跟\u0026quot;$*\u0026quot;。\n结论： # 先说结论，网上的解释一大堆，但其实可以用两句话来概括：\n不加引号的时候，$@跟$*的作用一致 加引号的时候，\u0026quot;$@\u0026quot;的作用仍然跟$@保持一致，没发生变化，而\u0026quot;$*\u0026quot;会将所有参数视为单个完整参数。 示例： # 新建如下脚本文件test.sh：\n#!/usr/bin/bash count=1 for name in $* do echo \u0026#34;Parameter #$count = $name\u0026#34; (( count++ )) done echo \u0026#34;==============================\u0026#34; count=1 for name in $@ do echo \u0026#34;Parameter #$count = $name\u0026#34; (( count = count+1 )) done 使用chmod+x test.sh使其具有执行权限，然后：\n./test.sh zhangsan lisi wangmazi ergouzi 可以看到如下结果：\n❯❯❯ ./test2.sh zhangsan lisi wangmazi ergouzi Parameter #1 = zhangsan Parameter #2 = lisi Parameter #3 = wangmazi Parameter #4 = ergouzi ============================== Parameter #1 = zhangsan Parameter #2 = lisi Parameter #3 = wangmazi Parameter #4 = ergouzi 可以看到，在没有引号的情况下，$@跟$*的作用是一致的，都是将传入的参数单个区分对待。\n再然后分将其中的$@跟$*两边加上引号，如下：\n#!/usr/bin/bash count=1 for name in \u0026#34;$*\u0026#34; do echo \u0026#34;Parameter #$count = $name\u0026#34; (( count++ )) done echo \u0026#34;==============================\u0026#34; count=1 for name in \u0026#34;$@\u0026#34; do echo \u0026#34;Parameter #$count = $name\u0026#34; (( count = count+1 )) done 再次执行，可以看到如下结果：\n❯❯❯ ./test2.sh zhangsan lisi wangmazi ergouzi Parameter #1 = zhangsan lisi wangmazi ergouzi ============================== Parameter #1 = zhangsan Parameter #2 = lisi Parameter #3 = wangmazi Parameter #4 = ergouzi 可以看到，与没有引号的$*不同，\u0026quot;$*\u0026quot;会将传入的所有参数，当成单个整体的参数来对待。\n","date":"31 March 2024","externalUrl":null,"permalink":"/posts/the-difference-of-variable/","section":"Posts","summary":"bash、zsh脚本中，$*变量跟$@变量的区别","title":"$*,$@,傻傻分不清楚？","type":"posts"},{"content":"","date":"31 March 2024","externalUrl":null,"permalink":"/tags/bash/","section":"Tags","summary":"","title":"Bash","type":"tags"},{"content":"","date":"31 March 2024","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"31 March 2024","externalUrl":null,"permalink":"/","section":"Coffee Weekly","summary":"","title":"Coffee Weekly","type":"page"},{"content":"","date":"31 March 2024","externalUrl":null,"permalink":"/tags/shell/","section":"Tags","summary":"","title":"Shell","type":"tags"},{"content":"","date":"31 March 2024","externalUrl":null,"permalink":"/categories/shell/","section":"Categories","summary":"","title":"Shell","type":"categories"},{"content":"","date":"31 March 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"31 March 2024","externalUrl":null,"permalink":"/tags/zsh/","section":"Tags","summary":"","title":"Zsh","type":"tags"},{"content":" first ","date":"30 March 2024","externalUrl":null,"permalink":"/resume/","section":"Coffee Weekly","summary":" first ","title":"Resume","type":"page"},{"content":"","date":"28 March 2024","externalUrl":null,"permalink":"/tags/blog/","section":"Tags","summary":"","title":"Blog","type":"tags"},{"content":"","date":"28 March 2024","externalUrl":null,"permalink":"/tags/%E5%8D%9A%E5%AE%A2/","section":"Tags","summary":"","title":"博客","type":"tags"},{"content":"好像每个写博客的作者或早或晚都会写篇博客，说自己为什么写博客，好吧，那我也来记录一下自己为什么要写博客。\n分享 # 我认为写作本身是不需要什么理由的，但从写作到写博客，对于我而言，最主要的原因是“分享”。\n这两年各种各样的笔记软件很火，极大地减少了大家写作或者说做笔记的难度。我自己从tiddlywiki到Logseq再到Obsidian，几乎每款软件都用过，到现在已经记了两年的笔记，这些东西，有的是我的学习笔记，有的是我在使用Linux时解决问题的方案，有的是我的读书心得，有的是我的心路历程，绝大多数情况下，它们都只是静静地躺在我的笔记仓库里，存储在计算机硬盘上一堆文本文件，没什么用，对我没用，也没有为同样遇到这些问题的人有用，所以我写博客主要是想把自己之前记的笔记整理出来，希望能对其他人有用。\n教学相长，提高清晰度 # 把自己的笔记整理成博客的过程，本质上也是一个把自己解决问题的方案传授给其他人的过程，所以对于自己以前用得稀里糊涂，不甚了解的东西，就需要刻意地提高清晰度，力求全面清晰、简洁，反而对自己也算是一个好处。\n","date":"28 March 2024","externalUrl":null,"permalink":"/posts/why-i-write-blogs/","section":"Posts","summary":"好像每个写博客的作者或早或晚都会写篇博客","title":"我为什么写博客？","type":"posts"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/tags/archlinux/","section":"Tags","summary":"","title":"ArchLinux","type":"tags"},{"content":"Linux下Wayland协议虽说已经推了很长一段时间了，Fedora最新的Gnome发行版甚至说要默认取消xorg协议，但我的ArchLinux在NVIDIA显卡的环境下，还是默认总是进入xorg会话，所以今天就来给大家分享下我在ArchLinux下，如何开启Wayland的过程。\n系统信息 # OS: Arch Linux x86_64 DE: Gnome 46.0 Kernel: 6.8.1-zen1-1-zen GPU 1: NVIDIA GeForce RTX 3050 Ti Mobile 准备工作 # 准备工作要先确保自己安装了正确的NVIDIA驱动程序。\n首先查看当前系统使用的内核版本：\nunmae -r 如果是使用的默认的Linux内核，则安装nvdia软件包：\nsudo pacman -S nvidia nvidia-utils 如果使用的其他修改版的内核，如Linux-zen，则安装nvidia-dkms:\nsudo pacman -S nvidia-dkms nvidia-utils 具体步骤 # 1. 修改 GDM 配置文件 # 修改gdm的配置文件。打开终端，编辑 /etc/gdm/custom.conf 文件：\n$ sudo gedit /etc/gdm/custom.conf 找到以下行：\n#WaylandEnable=false 将其修改为：\nWaylandEnable=true 保存并关闭文件。\n2. 更新 Mkinitcpio 模块 # 编辑 /etc/mkinitcpio.conf 文件：\n$ sudo vim /etc/mkinitcpio.conf 将 MODULES=() 替换为：\nMODULES=(nvidia nvidia_modeset nvidia_uvm nvidia_drm) 如果大家用的是btrfs文件系统，那么只需要在modules中的btrfs参数后，添加以上内容，如下：\nMODULES=(btrfs nvidia nvidia_modeset nvidia_uvm nvidia_drm) 保存，执行以下命令来重新生成initramfs镜像文件：\n$ sudo mkinitcpio -P mkinitcpio: mkinitcpio 是一个用于创建 initramfs 的工具。它负责收集和打包所需的文件、驱动程序和工具，以便它们在启动时可以被 Linux 内核加载。\n-P: --allpresents,选项表示重新生成 initramfs 文件。该选项会读取/etc/mkinitcpio.d/文件夹下的所有预设配置文件，并依此重新生成initramfs文件。如该文件夹下的linux-zen.preset文件：\n# mkinitcpio preset file for the \u0026#39;linux-zen\u0026#39; package ALL_config=\u0026#34;/etc/mkinitcpio.conf\u0026#34; ALL_kver=\u0026#34;/boot/vmlinuz-linux-zen\u0026#34; # PRESETS=(\u0026#39;default\u0026#39; \u0026#39;fallback\u0026#39;) PRESETS=(\u0026#39;default\u0026#39;) #default_config=\u0026#34;/etc/mkinitcpio.conf\u0026#34; default_image=\u0026#34;/boot/initramfs-linux-zen.img\u0026#34; #default_options=\u0026#34;\u0026#34; #fallback_config=\u0026#34;/etc/mkinitcpio.conf\u0026#34; fallback_image=\u0026#34;/boot/initramfs-linux-zen-fallback.img\u0026#34; fallback_options=\u0026#34;-S autodetect\u0026#34; 可以看到，默认情况下，通过preset文件，mkinitcpip会生成fallback备用镜像，但在添加NVIDIA内核模块后，通过sudo mkinitcpio -P产生的initramfs文件，即/boot/initramfs-linux-zen.img会明显增大，可能会造成boot分区的空间不足，如果遇到这种情况，我们就可以通过修改配置文件，禁止其生成fallback镜像。\n3. 添加内核参数 # 根据你的启动管理器是 systemd-boot 还是 grub，你需要添加相应的内核参数。\n对于 systemd-boot，编辑 /boot/loader/entries/arch.conf 文件，并添加 nvidia_drm.modeset=1 到 options 字段：\ntitle Arch Linux linux /vmlinuz-linux initrd /amd-ucode.img initrd /initramfs-linux.img options root=/dev/nvme1 rw nvidia_drm.modeset=1 更新启动配置：\n$ sudo bootctl update 对于 grub，编辑 /etc/default/grub 文件，并添加 nvidia-drm.modeset=1：\nGRUB_CMDLINE_LINUX_DEFAULT=\u0026#34;loglevel=3 quiet nvidia_drm.modeset=1\u0026#34; 然后更新 grub 配置：\n$ sudo grub-mkconfig -o /boot/grub/grub.cfg 对于使用uki(unified kernel image)的用户：\n先获取原先的内核参数： cat /proc/cmdline root=PARTUUID=c78eb323-bc0d-4e3f-9ce6-2ee65ce475fe zswap.enabled=0 rootflags=subvol=root rw rootfstype=btrfs 添加nvidia内核参数 # 创建/etc/cmdline.d/nvidia.conf文件 sudo mkdir /etc/cmdline.d cd /etc/cmdline.d sudo touch nvidia.conf # 编辑`nvidia.conf`: sudo nvim nvidia.conf # 在原先内核参数后添加nvidma-drm.modeset=1，如下： root=PARTUUID=c78eb323-bc0d-4e3f-9ce6-2ee65ce475fe zswap.enabled=0 rootflags=subvol=root rw rootfstype=btrfs nvidia-drm.modeset=1 重新生成统一内核镜像： sudo mkinitcpio -P 4. 禁用 GDM udev 规则 # $ sudo ln -s /dev/null /etc/udev/rules.d/61-gdm.rules 该命令用于创建一个空的符号链接来禁用GDM的udev规则，这样做的目的是为了避免 GDM 强制使用 Xorg 作为显示服务器。通过禁用这些规则，用户可以在 GDM 登录界面选择使用 Wayland 或 X11 作为显示协议，从而提供了更多的灵活性和选择。这对于希望尝试或切换到 Wayland 显示协议的用户来说是有用的。\n5. 重启并选择Wayland # 配置完成后，重启电脑并进入gdm登录界面：会发现启动选择器的图形样式有所变化。你可以通过选择 GNOME 来启动 Wayland，或者通过选择 GNOME on Xorg 回到 X11。\n要确认你正在使用 Wayland，可以执行以下命令：\n$ echo $XDG_SESSION_TYPE 拓展： # initramfs的作用是什么？\nLinux中的initramfs是用于在启动Linux内核之前提供一个轻量级的临时文件系统，以支持加载必要的驱动程序和设置，特别是在引导过程中需要解密根文件系统或进行其他关键操作时。\n/etc/mkinitcpio.conf中各个选项的作用是什么？\nmkinitcpio.conf 文件是 Arch Linux 中 mkinitcpio 工具的配置文件，用于生成初始 RAM 环境。以下是一些常见选项的解释：\nMODULES：指定要包括在初始 RAM 环境中的内核模块列表。这些模块通常是用于引导和初始化硬件设备的。\nBINARIES：列出要包含在初始 RAM 环境中的二进制文件。这些文件通常是用于初始化和挂载文件系统的工具。\nFILES：指定要包括在初始 RAM 环境中的其他文件。这可以包括自定义脚本、配置文件等。\nHOOKS：定义要执行的挂载点和动作。这些挂载点和动作按顺序执行，用于初始化和准备系统以引导。\nCOMPRESSION：指定生成的初始 RAM 环境映像的压缩格式。通常是 gzip。\nCOMPRESSION_OPTIONS：包含与压缩相关的选项。\n这些选项允许你自定义生成的初始 RAM 环境，以适应特定的系统要求。你可以根据需要添加或删除内核模块、二进制文件和挂载点，以确保系统能够成功引导。\n/etc/mkinitcpio.conf文件中的hooks数组的作用：HOOKS=(base udev autodetect keyboard keymap modconf block filesystems fsck)\nmkinitcpio.conf 文件中的 HOOKS 配置指定了用于生成初始 RAM 环境 (initramfs) 的一系列挂载点和动作。在你提供的示例中，以下是每个挂载点/动作的作用：\nbase：这是初始 RAM 环境的基础，包括内核模块的加载和文件系统的初始化。\nudev：用于初始化 udev，这是 Linux 中的设备管理系统。它有助于检测和管理硬件设备。\nautodetect：这个挂载点的作用是自动检测和加载所需的硬件驱动程序和内核模块。\nkeyboard：用于初始化键盘支持，确保在引导过程中能够与键盘进行交互。\nkeymap：加载键盘映射，以确保键盘的布局和字符映射正确。\nmodconf：这个挂载点用于自动检测并加载与硬件相关的内核模块。\nblock：用于初始化块设备支持，以便在引导过程中能够访问磁盘。\nfilesystems：加载文件系统支持，以便在引导后能够挂载根文件系统。\nfsck：该挂载点用于文件系统检查，确保文件系统的完整性。\n总的来说，HOOKS 的配置确定了在初始 RAM 环境中执行的步骤，以便在引导过程中能够成功加载所需的驱动程序、初始化设备并准备文件系统。这个配置根据系统的需要可以进行自定义，以确保系统能够成功引导。\n","date":"27 March 2024","externalUrl":null,"permalink":"/posts/enable-wayland-on-nvidia-gpu/","section":"Posts","summary":"ArchLinux下Gnome桌面NVIDIA显卡开启Wayland","title":"ArchLinux下Gnome桌面NVIDIA显卡开启Wayland","type":"posts"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/tags/gnome/","section":"Tags","summary":"","title":"Gnome","type":"tags"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/tags/nvidia/","section":"Tags","summary":"","title":"NVIDIA","type":"tags"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/tags/wayland/","section":"Tags","summary":"","title":"Wayland","type":"tags"},{"content":"","date":"25 March 2024","externalUrl":null,"permalink":"/tags/krishinamurti/","section":"Tags","summary":"","title":"Krishinamurti","type":"tags"},{"content":"","date":"25 March 2024","externalUrl":null,"permalink":"/tags/%E5%85%8B%E9%87%8C%E6%96%AF%E9%82%A3%E7%A9%86%E6%8F%90/","section":"Tags","summary":"","title":"克里斯那穆提","type":"tags"},{"content":" 前言 # 大学读余华的活着，看到福贵经历那么多的苦难，到老什么都没留下，觉得挺没劲。到最后，岁月磨平一切伤痕，留下的只有平静\u0026hellip;.只记得余华在序言中写道：“活着就是活着，我觉得自己写了高尚的作品。”\n福贵的经历，让我想到父亲的经历、爷爷的经历，还有爷爷的爸爸，也就是太爷爷的经历，这些人的具体经历，是小孩没娘，说来话长，却又跟福贵的经历非常相似，他们人生的主旋律都可以用两个字来概括，那就是——苦难。\n这些苦难，迫使大学时的我着了魔一样想要找出人活着的意义，遂经常逃课，在图书馆读马哲、金刚经、心经、坛经，也读道德经、大学、传习录，我知道这些书对学业没什么助益，但我太想知道这个答案了，遂不管不顾地读了下去。一种强烈的直觉是，这类书跟教科书还有专业书不一样，背下来记下来是没用的，自己要找的应该是一个终极的答案，以至于当我遇到它时，我会知道它是对的。而任何带有强制性，美化性的说教，教条，它们永远不可能是正确答案。\n说来惭愧，在读了很多这种乱七八糟的书之后，我终于找到了自己直觉中的终极答案，答案来自于一个很多人都听过的故事，说五祖弘忍法师即将传授衣法时命众门人各自作偈一首，第一个呈上心偈的是素有“上座弟子”兼“教授师”之称的神秀，他的偈语是：“身是菩提树，心如明镜台；时时勤拂拭，莫使有尘埃。” 而曾被五祖戏称为獦獠的惠能所呈的心偈则为：“菩提本无树，明镜亦无台；佛性常清净，何处有尘埃？”\n佛经中有“标月之指”的譬喻，意思是以手指月，应随指见月，见月忘指，莫执指而不见月。我知道祖师慧能的这句偈有我想要的答案，但可惜的是，不管我读再多的佛经，看再多的释义，那些都是以手指月的手，并非月亮本身，直到现在，我自己也能绉出很多看似很有道理的答案了，但我知道，那并不是我想要看见的月亮。\n克里斯那穆提是谁？ # 👉点此 | Krishnamurti 查看详细介绍。\n👉克里希那穆提（Krishnamurti）是20世纪著名的印度思想家和哲学家，1895年出生，1986年去世。克里希那穆提的思想强调当下的觉知和对自由、智慧以及人类心灵的探索。\n什么是“我”？ # 什么是“思考”？ # trst哈哈哈\n什么是“生命”？ # 创造力的源泉是什么？ # 我们为什么恐惧？ # 时间真的存在吗？ # ","date":"25 March 2024","externalUrl":null,"permalink":"/posts/philosophy-of-krishnamurti/","section":"Posts","summary":"克里斯那穆提关于恐惧、我、生命、时间、恐惧的思想总结","title":"克里斯那穆提思想总结","type":"posts"},{"content":"","date":"25 March 2024","externalUrl":null,"permalink":"/categories/%E7%81%B5%E6%80%A7/","section":"Categories","summary":"","title":"灵性","type":"categories"},{"content":"","date":"25 March 2024","externalUrl":null,"permalink":"/tags/regex/","section":"Tags","summary":"","title":"Regex","type":"tags"},{"content":"","date":"25 March 2024","externalUrl":null,"permalink":"/tags/regex101/","section":"Tags","summary":"","title":"Regex101","type":"tags"},{"content":"","date":"25 March 2024","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":" 前言 # 做 regex101练习题的时候，发现答案不好找，搜了一圈，社区的态度是，为了防止大家抄袭答案，所以不公布答案为好。\n这样做，好处当然有，但做不出来的题，找不到正确答案就很难受，更不要说借鉴那些表达式最短的答案了。\n我自己总共做了前13道题，其中1-8道以及12道，答案通过，9-11、还有13道，答案未能通过。这里也是提醒大家，作者的答案肯定不是最优答案，只是给大家提供借鉴，如果大家有更好的答案，或者有其他我没解决的题的答案，欢迎大家评论区流言交流。\n第一题——匹配word字符模式 # 题目：Check if a string contains the word word in it (case insensitive). If you have no idea, I guess you could try /word/.\n答案：/\\bword\\b/i\n`\\b`表示单词边界，表示单词跟空格间的位置。 第二题——将小写字母i替换为I # 题目：Use substitution to replace every occurrence of the word i with the word I (uppercase, I as in me). E.g.: i'm replacing it. am i not? -\u0026gt; I'm replacing it. am I not?.\nA regex match is replaced with the text in the Substitution field when using substitution.\n答案：将/\\bi\\b/g替换为I。\n第三题——找到大写的辅音字母 # 题目：With regex you can count the number of matches. Can you make it return the number of uppercase consonants (B,C,D,F,..,X,Y,Z) in a given string? E.g.: it should return 3 with the text ABcDeFO!. Note: Only ASCII. We consider Y to be a consonant!\nExample: the regex /./g will return 3 when run against the string abc.\n答案：/[BCDFGHJ-NP-TV-Z]/g\n第四题——匹配整数 # 题目：Count the number of integers in a given string. Integers are, for example: 1, 2, 65, 2579, etc.\n答案：/\\d+/g\n`\\d`代表所有的阿拉伯数字字符，另外，`\\D`代表所有的非阿拉伯数字字符。 第五题——匹配等于或者超过4个的空格字符 # 题目：Find all occurrences of 4 or more whitespace characters in a row throughout the string.\n答案：/\\s{4,}/g\n`\\s`代表任意空白字符，`{4,}`表示至少前面的`\\s`至少出现4次。 第六题——去除重复字符 # 题目：Oh no! It seems my friends spilled beer all over my keyboard last night and my keys are super sticky now. Some of the time whennn I press a key, I get two duplicates.\nCan you ppplease help me fix thhhis?\n答案：将/(\\s|\\S)\\1{2}/g替换为$1\n意思是他的键盘出了问题，按一次键帽，会多出两个连续的字符，比如`ppplease`和`thhhis`，所以思路就是先找到重复3次的任意字符，不管是空白字符还是非空白字符，然后删除掉重复的两个字符就好。 `\\s`代表任意空白字符，而`\\S`代表任意非空白字符，所以先用`(\\s|\\S)`就是将所有字符分组，不管是空白字符还是非空白字符，同时将其捕获为分组1；`\\1{2}`是说指前面捕获到的1号分组又连续出现两次，这种情况下，就将该连续出现三次的字符替换为分组1。 第七题 # 题目：\n第八题 # 题目：Strip all HTML tags from a string. HTML tags are enclosed in \u0026lt; and \u0026gt;.\nThe regex will be applied on a line-by-line basis, meaning partial tags will need to be handled by the regex. Don\u0026rsquo;t worry about opening or closing tags; we just want to get rid of them all.\nNote: This task is meant to be a learning exercise, and not necessarily the best way to parse HTML.\n答案：将/.*\u0026gt;|\u0026lt;[^\u0026lt;\u0026gt;]*\u0026gt;?/g替换为空。\n第十二题 # 题目：Could you help me validate my input and only match positive integers between the range of 0 and 100?\nThere can be several numbers in a string which I would want to retrieve.\nTry out these example strings:\nSam has 200 apples. He gives Todd 20 and Mary 125. The weather is -5 C today, but will be +5 C tomorrow.\n答案：/\\b(?:(?\u0026lt;!-)\\d|(?\u0026lt;!-)[1-9]\\d|(?\u0026lt;!-)100)\\b/gm\n","date":"25 March 2024","externalUrl":null,"permalink":"/posts/my-anwser-of-regex101-quiz/","section":"Posts","summary":"regex101 quiz 1-8,12题的答案","title":"我的regex101答案","type":"posts"},{"content":"","date":"25 March 2024","externalUrl":null,"permalink":"/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","section":"Tags","summary":"","title":"正则表达式","type":"tags"},{"content":"","date":"25 March 2024","externalUrl":null,"permalink":"/series/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","section":"Series","summary":"","title":"正则表达式","type":"series"},{"content":"","date":"25 March 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"正则表达式，一直在用，但用得稀里糊涂。尤其在Linux下，一切皆文件，Linux三剑客：“grep，awk，sed”，哪个都离不开正则表达式，所以抽个时间，巩固一下正则表面式的内容。\n用到的网站 # 👉 维基百科|正则表达式，先大致了解一下正则表达式。 👉 regexlearn，比较基础的练习，总共56道题，十几分钟就能做完，动画做得很直观，加深理解。 👉 regex101，总共28道测试题，有难度，我自己做到前9道。除了测验之外，正则表达式的所有内容基本都能在这个网站上找到，比较靠谱的一个网站。 👉各种gpt助手，不必多言。 正则表达式重难点 # 贪婪模式与非贪婪模式 # 贪婪模式：尽可能多地匹配相符内容。\n比如： a.*a，a代表首字母，.点字符表示除回车跟换行符的任意单个字符，*代表对之前.的贪婪模式匹配，即尽可能多地匹配任意多个单个字符，直到遇见下一个字母a，效果如下：\n非贪婪模式：与贪婪模式相反，仅匹配最少量的必要相符内容。\n比如：r\\w*?，r表示首字母，\\w在正则表达式中代表字母、数字或下划线，后面的*?表示针对\\w的非贪婪模式匹配，所以最终效果就是，匹配以r为首的，后续为字母、数字、下划线字符模式中的r,具体效果如下：\n零宽断言 # 零宽断言是正则表达式中的一种特殊的匹配模式，所谓断言，是说当它们在匹配字符串时，断言当前位置的前面或后面应该满足某种条件。零宽，是说以上这种断言都是零宽度的，它们自身不匹配任何字符，只是用来断言当前位置的前面或后面是否满足特定的条件。\n根据匹配位置的不同，可分为先行断言跟后行断言，所谓先行断言，是说断言当前位置的后面应该满足某种条件；而后行断言，是说当前位置的前面应该满足某种条件；又根据匹配条件的不同，可分为正向断言跟负向断言，所谓正向，即表示肯定，负向，即表示否定。排列组合下来，总共有以下四种零宽断言的模式：\n正向先行断言（Positive Lookahead）：(?=pattern)，表示断言在当前位置的后面，模式 pattern会出现，如： 正向先行断言 \\d在正则表达式中代表数字字符，+是对\\d的修饰，表示至少要有一个\\d，后面的(?=PM)，是对之前\\d+的修饰，即断言\\d+之后必有PM，但(?=PM)自身却不匹配任何字符，于是最终匹配到的只有PM之前的数字3。\n负向先行断言（Negative Lookahead）：(?!pattern)，表示在当前位置之后，模式 pattern 不会出现，如： 负向先行断言 \\d在正则表达式中代表数字字符，+是对\\d的修饰，表示至少要有一个\\d，后面的(?!PM)，是对之前\\d+的修饰，即断言\\d+之后不能有PM，但(?!PM)自身却不匹配任何字符，于是最终匹配到的只有后面没有PM的数字4。\n正向后行断言（Positive Lookbehind）：(?\u0026lt;=pattern)，表示在当前位置之前，模式 pattern 会出现，如： 正向后行断言 \\$在正则表达式中代表符号$本身，因$自身在正则表达式中具有匹配文本行尾的含义，所以这里要用到转义字符\\，\\d在正则表达式中代表数字字符，+是对\\d的修饰，表示至少要有一个\\d，前面的(?\u0026lt;=PM)，是对后面\\d+的修饰，即断言\\d+之前必有$字符，但(?\u0026lt;=\\$)自身却不匹配任何字符，于是最终匹配到的只有$之后的数字5。\n负向后行断言（Negative Lookbehind）：(?\u0026lt;!pattern)，表示在当前位置之前，模式 pattern 不应该出现，如： 负向后行断言 \\$在正则表达式中代表符号$本身，因$自身在正则表达式中具有匹配文本行尾的含义，所以这里要用到转义字符\\，\\d在正则表达式中代表数字字符，+是对\\d的修饰，表示至少要有一个\\d，前面的(?\u0026lt;!PM)，是对后面\\d+的修饰，即断言\\d+之前不能出现$字符，但(?\u0026lt;!\\$)自身却不匹配任何字符，于是最终匹配到的是前面没有$字符的1024。\n总结：\n先行断言是从当前位置向后查找，用于约束当前位置之后的字符，而后行断言是从当前位置向前查找，用于约束当前位置之前的字符。 正向断言是约束条件应该出现，而负向断言是约束条件不应该出现。 先行断言和后行断言都是零宽断言，意味着它们只是做条件约束，而不会消耗字符串。 分组和引用 # 在正则表达式中，分组和引用，可以帮助我们匹配和操作字符串中的特定部分。其中，分组允许我们将多个模式组合在一起，并对它们进行操作，而引用则允许我们在同一正则表达式中引用先前匹配的内容。在正则表达式中，使用圆括号 () 可以创建一个分组，被创建的分组通常被视为一个整体。根据分组是否能被引用，分为捕获分组跟非捕获分组，其中，捕获分组又可分为数字分组跟命名分组。具体如下：\n数字捕获分组跟数字引用\n数字捕获分组跟数字引用是对应的，即被数字分组捕获的分组，需要通过数字引用来重新引用。如下： (ha)表示利用 ()将 ha 捕获为数字分组1，并在之后使用数字引用\\1引用捕获到的第一个分组，于是匹配到的字符串，是两个连续的 ha。\n命名捕获分组跟命名引用\n命名捕获分组跟命名引用是对应的，即被命名分组捕获的分组，需要通过命名引用来重新引用。命名捕获组的语法如下：(?\u0026lt;name\u0026gt;group)或(?'name'group)，其中name表示捕获组的名称，group表示捕获组里面的正则。我们可以用\\k\u0026lt;name\u0026gt; 或 \\k'name'的形式来对前面的命名捕获组捕获到的值进行引用，如下： (?\u0026lt;first\u0026gt;ha)表示使用 (?\u0026lt;first\u0026gt;ha)命名捕获的方式将 ha 捕获为命名分组first，而(\\k\u0026lt;first\u0026gt;)表示命名分组first的引用。\n⚠️ 需要注意的是，这里的()前的?并非是非捕获分组的意思，而是命名捕获的格式。\n非捕获分组\n非捕获组，跟捕获组相比，它不会把正则匹配到的内容保存到分组里面。 非捕获分组 字符串分组ha虽然被捕获，但却未被分组，所以它无法通过数字分组跟命名分组的方式被引用。\n非捕获分组，常用于在多个固定的字符串中匹配其中一个，如下： 非捕获分组被用于匹配固定字符串 如上，(?:white|black)该非捕获分组匹配到字符串white或black。\n但是，这里需要注意的是，非捕获分组跟正则表达式中的|表达式的区别，如下： |表达式没有包围在()里，其范围是整个正则表达式对， 即要么匹配|左边的内容，要么匹配|右边的内容。再比如，z|food能匹配z或food。(?:z|f)ood则匹配zood或food。\n分支重置分组\n分支重置组内的选择项共享相同的捕获组。语法是(?|regex)，其中(?|打开组，而regex可以是任意的正则表达式。如果不使用任何选择项或捕获分支重置组内的组，则其特殊功能将不起作用。那么它将作为一个非捕获组。\n如：正则表达式(?|(a)|(b)|(c))由一个带有三个选择项的分支重置组组成。此正则表达式匹配a ，b或c 。正则表达式只有一个捕获组，编号为1，由所有三个选择项共享。匹配结束后，$1存储a,b或c ，具体示例如下： 通过分支重置分组，分组1中，要么是a，要么是b，要么是c，所以当我们通过(?|(a)|(b)|(c))\\1\\1\\1，在重置分组后又引用三次1号分组，每次匹配到的，都是同一个字母。\n再比如： 匹配到的要么是apple apple，要么是banana banana。 将此与正则表达式(a)|(b)|(c)进行比较。后者也匹配a ，b或c 。但是它具有三个捕获组。匹配结束后，$1保留a或什么都不保留，$2保留b或什么都不保留，而$3保留c或什么都不保留。\n","date":"25 March 2024","externalUrl":null,"permalink":"/posts/learning-regex/","section":"Posts","summary":"学习正则表达式的相关网站\n正则表达式的难点","title":"学习正则表达式","type":"posts"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"}]