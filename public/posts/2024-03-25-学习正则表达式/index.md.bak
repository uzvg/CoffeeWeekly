---
title: 学习正则表达式
summary: |-
    学习正则表达式的相关网站
    正则表达式的难点
description: |-
    学习正则表达式用到的相关网站
    正则表达式比较难理解的知识点
categories: []
tags:
    - regex
    - 正则表达式
date: 2024-03-25T04:59:29.879Z
lastmod: 2024-03-25T09:50:14.548Z
draft: false
showComments: true
series:
    - 正则表达式
series_order: 1
seriesOpened: true
type: posts
keywords:
    - regex
    - regex101
    - 正则表达式
    - 零宽断言
slug: learning-regex
---

正则表达式，一直在用，但用得稀里糊涂。尤其在Linux下，一切皆文件，Linux三剑客：“grep，awk，sed”，哪个都离不开正则表达式，所以抽个时间，巩固一下正则表面式的内容。

## 用到的网站

* 先大致了解一下正则表达式 👉 [维基百科➡正则表达式](https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F)

* regexlearn总共56道题，比较基础，十几分钟就能做完，动画也做得很直观，方便加深理解👉[regexlearn](https://regexlearn.com/zh-cn/learn/regex101)

* 做题测试，总共28道练习题，目前我只做了前8道。除了测验之外，关于正则表达式的所有内容基本都能在这个网站上找到，算是比较靠谱的一个网站。👉[[regex101|https://regex101.com/quiz]]，
* ChatGpt也是一个好帮手。
* 
## 零宽断言

零宽断言是正则表达式中的一种特殊的匹配模式，所谓零宽，指的是这两种断言都是零宽度的，也就是说它们本身不匹配任何字符，只是用来断言当前位置的前面或后面是否满足特定的条件；所谓断言，是说当它们在匹配字符串时，断言当前位置的前面或后面应该满足某种条件。

根据匹配位置的不同，可分为先行断言跟后行断言，所谓先行断言，断言当前位置的后面应该满足某种条件；而后行断言，是当前位置的前面应该满足某种条件；又根据匹配条件的不同，可分为正向断言跟负向断言，所以正向，即肯定，负向，即否定。排列组合下来，总共有以下四种零宽断言的模式：

1. 正向先行断言（Positive Lookahead）：`(?=pattern)`，表示在当前位置的后面，模式 `pattern`会出现，如： ![](/imgs/Pastedimage20240312104339.png "正向先行断言")

2. 负向先行断言（Negative Lookahead）：`(?!pattern)`，表示在当前位置之后，模式 `pattern` 不会出现，如：![](/imgs/Pastedimage20240312104354.png "负向先行断言")

3. 正向后行断言（Positive Lookbehind）：`(?<=pattern)`，表示在当前位置之前，模式 `pattern` 会出现，如：![](/imgs/Pastedimage20240312104436.png "正向后行断言")

4. 负向后行断言（Negative Lookbehind）：`(?<!pattern)`，表示在当前位置之前，模式 `pattern` 不应该出现，如：![](/imgs/Pastedimage20240312104448.png "负向后行断言")

---
总结：
* 先行断言是从当前位置向后查找，用于约束当前位置之后的字符，而后行断言是从当前位置向前查找，用于约束当前位置之前的字符。
* 正向断言是约束条件应该出现，而负向断言是约束条件不应该出现。
* 先行断言和后行断言都是零宽断言，意味着它们只是做条件约束，而不会消耗字符串。

## 分组和引用 

在正则表达式中，分组和引用，可以帮助我们匹配和操作字符串中的特定部分。其中，分组允许我们将多个模式组合在一起，并对它们进行操作，而引用则允许我们在同一正则表达式中引用先前匹配的内容。在正则表达式中，使用圆括号 `()` 可以创建一个分组，被创建的分组通常被视为一个整体。根据分组是否能被引用，分为捕获分组跟非捕获分组，其中，捕获分组又可分为数字分组跟命名分组。具体如下：

1. 数字捕获分组跟数字引用

![](/imgs/Pastedimage20240314172703.png)

利用 `()`将 `ha` 捕获为分组1，并在之后用数字引用`\1`引用捕获到的第一个分组，匹配到的字符串，是两个连续的 `ha`
2. 命名捕获分组跟命名引用

![](/imgs/Pastedimage20240314172820.png)

使用 `(?<first>ha)`命名捕获的方式将 `ha` 捕获为命名分组`first`
⚠️ 需要注意的是，这里的`()`前的`?`并非是非捕获分组的意思，而是命名捕获的格式。

3. 非捕获分组 

![](/imgs/Pastedimage20240314173050.png)
最捕获分组，在不创建捕获分组的情况下，把数个标记组在一起。

4. 分支重置分组

![](/imgs/Pastedimage20240314173005.png)
分支重置分组，定义一个拥有相同序号的分组。

在 `(?|(a)|(b))` 中，两个分组（a 和 b）会被算作分组#1，匹配到的是三个连续的`a`或者三个连续的`b`。

需要注意的是，在分支重置分组中，

![](/imgs/Pastedimage20240314174202.png)

## 贪婪模式跟非贪婪模式

贪婪模式：`a*`,尽可能多地匹配相符内容，如下：
![](/imgs/Pastedimage20240314194706.png)
![](/imgs/Pastedimage20240314194636.png)

非贪婪模式：`a*?`，仅匹配最少量的必要相符内容，如下：
![](/imgs/Pastedimage20240314194636.png)